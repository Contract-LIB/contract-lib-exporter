package org.contractlib.templated;

import org.contractlib.ast.Term;
import org.contractlib.ast.Type;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public abstract class AbstractTemplateTranslation implements TemplateTranslation {
    protected final String timeStamp =
            "// This file is auto-generated by the ContractLib tool. Do not modify\n// "
            + Util.timestamp() + "\n\n";

    protected final Main options;

    private final Map<String, String> typeMap = makeTypeMap();
    private final Map<String, TermRenderer> termRendererMap = makeTermRendererMap();

    protected AbstractTemplateTranslation(Main options) {
        this.options = options;
    }

    protected final TermRenderer funAppRenderer(String symbol) {
        return (f, args) ->  symbol + "(" + Util.commatize(args, x->x) + ")";
    }


    protected Map<String, TermRenderer> makeTermRendererMap() {
        Map<String, TermRenderer> result = new HashMap<>();
        TermRenderer multiInfix = (f, args) -> "(" + args.stream().reduce((a, b) -> a + " " + f + " " + b).get() + ")";
        result.put("and", (f, args) -> "(" + args.stream().reduce((a, b) -> a + " && " + b).orElse("true") + ")");
        result.put("or", (f, args) -> "(" + args.stream().reduce((a, b) -> a + " || " + b).orElse("false") + ")");
        result.put("not", (f, args) -> "!" + args.getFirst());
        result.put("<", multiInfix);
        result.put("<=", multiInfix);
        result.put(">", multiInfix);
        result.put(">=", multiInfix);
        result.put("=", (f, args) -> "(" + args.stream().reduce((a, b) -> a + " == " + b).get() + ")");
        result.put("+", multiInfix);
        result.put("-", multiInfix);
        result.put("*", multiInfix);
        return result;
    }

    protected Map<String, String> makeTypeMap() {
        Map<String, String> result = new HashMap<>();
        result.put("Int", "int");
        result.put("Bool", "boolean");
        result.put("string", "String");
        return result;
    }

    protected static boolean isThisTerms(List<Term> terms) {
        return terms.size() == 1 && terms.getFirst() instanceof Term.Variable v && v.name().equals("this");
    }

    protected final void debug(String message, Object... args) {
        if (options.verbose) {
            System.out.printf(message + "\n", args);
        }
    }

    protected final String renderType(Type value) {
        if (value == null)
            return "void";
        return switch (value) {
            case Type.Sort sort -> typeMap.getOrDefault(sort.name(), sort.name()) +
                    sort.arguments().stream().map(this::renderType).reduce((a, b) -> a + ", " + b).map(a -> "<" + a + ">").orElse("");
            case Type.Param param -> param.name();
        };
    }

    protected String renderTerm(Term term, List<String> selectorNames) {
        switch (term) {
            case Term.Application app:
                if (isSelector(selectorNames, app)) {
                    return renderSelectorTerm(app);
                }

                var args = app.arguments().stream().map(a -> renderTerm(a, selectorNames)).toList();
                var renderer = termRendererMap.get(app.function());
                if (renderer != null) {
                    return renderer.render(app.function(), args);
                } else {
                    return app.function() + "(" + Util.commatize(app.arguments(), a -> renderTerm(a, selectorNames)) + ")";
                }
            case Term.Variable var:
                return var.name();
            case Term.Literal lit:
                return lit.value().toString();
            case Term.Old old:
                return renderOld(selectorNames, old);
            case Term.Binder binder:
                throw new RuntimeException("Binders are currently not supported in contracts");
        }
    }

    protected String renderOld(List<String> selectorNames, Term.Old old) {
        return renderTerm(old.argument(), selectorNames);
    }

    protected String renderSelectorTerm(Term.Application app) {
        return app.function();
    }

    private static boolean isSelector(List<String> selectorNames, Term.Application app) {
        return selectorNames.contains(app.function()) && AbstractTemplateTranslation.isThisTerms(app.arguments());
    }

}
